name: Backend CI/CD Pipeline

on:
  push:
    branches: [main, staging]
    paths:
      - "backend/**"
      - ".github/workflows/backend.yml"

  pull_request:
    branches: [main, staging]
    paths:
      - "backend/**"
      - ".github/workflows/backend.yml"

  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/backend

jobs:
  test-and-build:
    name: üß™ Test & Build
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      should-deploy: ${{ steps.check-deploy.outputs.should-deploy }}
      deploy-type: ${{ steps.check-deploy.outputs.deploy-type }}
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"

      - name: Run checks in parallel
        run: |
          cd backend
          # Run tests, formatting, and linting in parallel
          go test ./... &
          go fmt ./... &
          go vet ./... &
          wait

      - name: Check deployment requirements
        id: check-deploy
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "deploy-type=pr" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "deploy-type=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "deploy-type=staging" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "deploy-type=none" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        if: steps.check-deploy.outputs.should-deploy == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: steps.check-deploy.outputs.should-deploy == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        if: steps.check-deploy.outputs.should-deploy == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha
          flavor: |
            latest=false

      - name: Build and push Docker image
        if: steps.check-deploy.outputs.should-deploy == 'true'
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  deploy:
    name: üöÄ Deploy
    runs-on: ubuntu-latest
    needs: [test-and-build]
    if: needs.test-and-build.outputs.should-deploy == 'true'
    outputs:
      deployment-url: ${{ steps.deploy-result.outputs.deployment-url }}
      deployment-port: ${{ steps.deploy-result.outputs.deployment-port }}
      deployment-branch: ${{ steps.deploy-result.outputs.deployment-branch }}
    environment:
      name: ${{ needs.test-and-build.outputs.deploy-type == 'production' && 'production' || 'staging' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine deployment context
        id: context
        run: |
          case "${{ needs.test-and-build.outputs.deploy-type }}" in
            "production")
              echo "branch=production" >> $GITHUB_OUTPUT
              echo "port=8080" >> $GITHUB_OUTPUT
              echo "domain=api.ytclipper.com" >> $GITHUB_OUTPUT
              echo "target-dir=/opt/ytclipper/production/backend" >> $GITHUB_OUTPUT
              echo "env-name=production" >> $GITHUB_OUTPUT
              ;;
            "staging")
              echo "branch=staging" >> $GITHUB_OUTPUT
              echo "port=8081" >> $GITHUB_OUTPUT
              echo "domain=api-staging.ytclipper.com" >> $GITHUB_OUTPUT
              echo "target-dir=/opt/ytclipper/deployments/staging/backend" >> $GITHUB_OUTPUT
              echo "env-name=staging" >> $GITHUB_OUTPUT
              ;;
            "pr")
              BRANCH="pr-${{ github.event.number }}"
              PORT_OFFSET=$((${{ github.event.number }} % 100))
              PORT=$((8100 + $PORT_OFFSET))
              echo "branch=$BRANCH" >> $GITHUB_OUTPUT
              echo "port=$PORT" >> $GITHUB_OUTPUT
              echo "domain=api-$BRANCH.ytclipper.com" >> $GITHUB_OUTPUT
              echo "target-dir=/opt/ytclipper/deployments/$BRANCH/backend" >> $GITHUB_OUTPUT
              echo "env-name=staging" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Create deployment artifacts
        run: |
          mkdir -p deploy-temp
          cp docker/compose.yml deploy-temp/

          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')

          # Generate unique tag for this deployment
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            IMAGE_TAG="pr-${{ github.event.number }}"
          else
            IMAGE_TAG="${{ github.ref_name }}"
          fi

          cat > deploy-temp/.env << EOF
          # Docker configuration
          BACKEND_IMAGE=ghcr.io/$REPO_LOWER/backend:$IMAGE_TAG
          BACKEND_PORT=${{ steps.context.outputs.port }}
          CONTAINER_SUFFIX=${{ steps.context.outputs.branch }}

          # Server configuration
          PORT=8080
          ENV=${{ steps.context.outputs.env-name }}
          LOG_LEVEL=info
          LOG_PRETTY=false
          GIN_MODE=release

          # Database configuration
          DATABASE_URL=${{ secrets.DATABASE_URL }}

          # Google oauth configuration
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI=${{ secrets.GOOGLE_REDIRECT_URI }}

          # JWT configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_ACCESS_TOKEN_EXPIRY=24h
          JWT_REFRESH_TOKEN_EXPIRY=672h
          JWT_ISSUER=ytclipper-api
          JWT_AUDIENCE=ytclipper-app

          AUTH_JWT_SECRET=${{ secrets.AUTH_JWT_SECRET }}
          AUTH_JWT_EXPIRY_HOURS=72
          AUTH_TOKEN_ISSUER=ytclipper-app
          AUTH_PASSWORD_RESET_EXPIRY=24h

          COOKIE_DOMAIN=.ytclipper.com
          COOKIE_SECURE=true

          # API configuration
          API_TIMEOUT=30s
          API_RATE_LIMIT=100

          # OpenAI configuration
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          OPENAI_EMBEDDING_MODEL=text-embedding-3-small

          # SMTP
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          FROM_EMAIL=${{ secrets.FROM_EMAIL }}
          FROM_NAME=${{ secrets.FROM_NAME }}
          SMTP_USE_TLS=true
          SMTP_USE_SSL=false

          EOF

      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            set -e

            TARGET_DIR="${{ steps.context.outputs.target-dir }}"
            CONTAINER_NAME="ytclipper-${{ steps.context.outputs.branch }}-backend"
            DOMAIN="${{ steps.context.outputs.domain }}"
            PORT="${{ steps.context.outputs.port }}"

            echo "üöÄ Deploying to $TARGET_DIR"
            echo "üîç Target container: $CONTAINER_NAME"
            echo "üîç Target domain: $DOMAIN"
            echo "üîç Target port: $PORT"

            # Create directory
            mkdir -p "$TARGET_DIR"

            # List current containers for debugging
            echo "üì¶ Current containers before deployment:"
            docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            # SAFE CONTAINER CLEANUP: Only remove the exact container we're about to deploy
            echo "üîç Checking for existing container with name: $CONTAINER_NAME"
            EXISTING_CONTAINER=$(docker ps -aq --filter "name=^${CONTAINER_NAME}$" || true)
            if [ -n "$EXISTING_CONTAINER" ]; then
              echo "üõë Found existing container with EXACT name: $CONTAINER_NAME"
              echo "üõë Container ID: $EXISTING_CONTAINER"
              echo "üõë Stopping and removing ONLY this specific container"
              docker rm -f "$CONTAINER_NAME"
              echo "‚úÖ Container removed successfully"
            else
              echo "‚ÑπÔ∏è  No existing container found with exact name: $CONTAINER_NAME"
            fi

            # Verify no port conflicts
            PORT_IN_USE=$(docker ps --format "table {{.Names}}\t{{.Ports}}" | grep ":$PORT->" || true)
            if [ -n "$PORT_IN_USE" ]; then
              echo "‚ö†Ô∏è  Warning: Port $PORT is already in use:"
              echo "$PORT_IN_USE"
              
              # Check if it's our own container that we just removed
              if echo "$PORT_IN_USE" | grep -q "$CONTAINER_NAME"; then
                echo "‚ÑπÔ∏è  Port conflict is from our own container that we just removed, continuing..."
              else
                echo "‚ùå Deployment aborted due to port conflict with another container"
                exit 1
              fi
            fi

      - name: Upload deployment files
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: "deploy-temp/*"
          target: "${{ steps.context.outputs.target-dir }}"
          strip_components: 1

      - name: Start services and configure nginx
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            set -e

            TARGET_DIR="${{ steps.context.outputs.target-dir }}"
            DOMAIN="${{ steps.context.outputs.domain }}"
            PORT="${{ steps.context.outputs.port }}"
            CONTAINER_NAME="ytclipper-${{ steps.context.outputs.branch }}-backend"

            # FINAL SAFETY CHECK: Verify protected containers are still running
            if [[ "${{ needs.test-and-build.outputs.deploy-type }}" == "pr" ]]; then
              echo "üõ°Ô∏è  FINAL SAFETY CHECK: Verifying production containers are untouched"
              PROTECTED_CONTAINERS=$(docker ps --format "{{.Names}}" | grep -E "(production|staging)" | grep -v "pr-" || true)
              if [ -n "$PROTECTED_CONTAINERS" ]; then
                echo "‚úÖ Protected containers still running:"
                echo "$PROTECTED_CONTAINERS"
              else
                echo "‚ö†Ô∏è  No protected containers found running - this might be expected"
              fi
            fi

            # Login to registry and start container
            cd "$TARGET_DIR"
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin

            # Pull image first to ensure it's available
            BACKEND_IMAGE=$(grep "^BACKEND_IMAGE=" .env | cut -d'=' -f2)
            echo "üîÑ Pulling image: $BACKEND_IMAGE"
            docker pull "$BACKEND_IMAGE"

            # Start the container using direct docker run instead of compose to avoid any interference
            echo "üöÄ Starting container directly with docker run"
            docker run -d \
              --name "$CONTAINER_NAME" \
              --restart unless-stopped \
              -p "$PORT:8080" \
              --dns 8.8.8.8 \
              --dns 8.8.4.4 \
              --dns 1.1.1.1 \
              --env-file .env \
              -e ENV="$(grep "^ENV=" .env | cut -d'=' -f2)" \
              -e LOG_LEVEL="${LOG_LEVEL:-info}" \
              -e LOG_PRETTY="${LOG_PRETTY:-true}" \
              -e API_TIMEOUT="${API_TIMEOUT:-30s}" \
              -e GIN_MODE="${GIN_MODE:-release}" \
              -e PORT=8080 \
              "$BACKEND_IMAGE"

            # Verify container started successfully
            sleep 5
            if ! docker ps | grep -q "$CONTAINER_NAME"; then
              echo "‚ùå Container failed to start: $CONTAINER_NAME"
              docker logs "$CONTAINER_NAME" || echo "No logs available"
              exit 1
            fi

            echo "‚úÖ Container started successfully: $CONTAINER_NAME"

            # FINAL VERIFICATION: Check that protected containers are still running
            if [[ "${{ needs.test-and-build.outputs.deploy-type }}" == "pr" ]]; then
              echo "üîç Final verification - checking all containers:"
              docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            fi

            # Configure nginx
            sudo tee /etc/nginx/sites-available/$DOMAIN > /dev/null << EOF
            server {
              listen 80;
              server_name $DOMAIN;
              return 301 https://\$host\$request_uri;
            }
            server {
              listen 443 ssl;
              server_name $DOMAIN;
              ssl_certificate /etc/letsencrypt/live/ytclipper.com/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/ytclipper.com/privkey.pem;
              location / {
                proxy_pass http://localhost:$PORT;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
              }
            }
            EOF

            sudo ln -sf "/etc/nginx/sites-available/$DOMAIN" "/etc/nginx/sites-enabled/$DOMAIN"
            sudo nginx -t && sudo systemctl reload nginx

      - name: Health check
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            PORT="${{ steps.context.outputs.port }}"

            # Wait for service to be ready
            for i in {1..30}; do
              if curl -f -s http://localhost:$PORT/health > /dev/null; then
                echo "‚úÖ Service is healthy on port $PORT"
                exit 0
              fi
              echo "‚è≥ Waiting for service to be ready... ($i/30)"
              sleep 2
            done

            echo "‚ùå Health check failed after 60 seconds"
            exit 1

      - name: Set deployment outputs
        id: deploy-result
        run: |
          echo "deployment-url=https://${{ steps.context.outputs.domain }}" >> $GITHUB_OUTPUT
          echo "deployment-port=${{ steps.context.outputs.port }}" >> $GITHUB_OUTPUT
          echo "deployment-branch=${{ steps.context.outputs.branch }}" >> $GITHUB_OUTPUT

  comment-pr:
    name: üí¨ Comment on PR
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() && github.event_name == 'pull_request'
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Comment on successful deployment
        if: needs.deploy.result == 'success'
        uses: marocchino/sticky-pull-request-comment@v2.1.0
        with:
          header: "backend-deployment"
          message: |
            ## üöÄ Backend Deployment Successful!

            Your backend changes have been deployed and are ready for testing:

            - **üîó URL**: ${{ needs.deploy.outputs.deployment-url }}
            - **üì¶ Branch**: ${{ needs.deploy.outputs.deployment-branch }}
            - **üî¢ Port**: ${{ needs.deploy.outputs.deployment-port }}
            - **‚è∞ Deployed**: ${{ github.event.head_commit.timestamp }}

            _This deployment will be automatically cleaned up when the PR is closed._

      - name: Comment on failed deployment
        if: needs.deploy.result == 'failure'
        uses: marocchino/sticky-pull-request-comment@v2.1.0
        with:
          header: "backend-deployment"
          message: |
            ## ‚ùå Backend Deployment Failed

            The deployment failed. Please check the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.

            Common issues:
            - Build errors
            - VPS connectivity issues
            - Port conflicts
            - Database connection issues

            _Push new changes to retry the deployment._

  cleanup-pr:
    name: üßπ Cleanup PR Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    steps:
      - name: Cleanup deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            set -e

            BRANCH="pr-${{ github.event.number }}"
            CONTAINER_NAME="ytclipper-$BRANCH-backend"
            DOMAIN="api-$BRANCH.ytclipper.com"
            DEPLOYMENT_DIR="/opt/ytclipper/deployments/$BRANCH"

            echo "üßπ Cleaning up backend deployment for $BRANCH"
            echo "üîç Looking for container: $CONTAINER_NAME"
            echo "üîç Looking for domain: $DOMAIN"
            echo "üîç Looking for directory: $DEPLOYMENT_DIR"

            # List all containers to help debug
            echo "üì¶ Current containers:"
            docker ps -a --format "table {{.Names}}\t{{.Status}}"

            # Stop and remove container (try both exact and partial matches)
            CONTAINERS_FOUND=$(docker ps -aq -f name="$CONTAINER_NAME" || true)
            if [ -n "$CONTAINERS_FOUND" ]; then
              echo "‚úÖ Found containers: $CONTAINERS_FOUND"
              echo "üõë Stopping and removing container: $CONTAINER_NAME"
              docker rm -f "$CONTAINER_NAME"
            else
              echo "‚ÑπÔ∏è  No containers found with name: $CONTAINER_NAME"
              # Try to find containers with partial name match
              PARTIAL_CONTAINERS=$(docker ps -aq --filter "name=ytclipper-$BRANCH" || true)
              if [ -n "$PARTIAL_CONTAINERS" ]; then
                echo "‚úÖ Found containers with partial match: $PARTIAL_CONTAINERS"
                for container in $PARTIAL_CONTAINERS; do
                  CONTAINER_NAME_FULL=$(docker ps -a --format "{{.Names}}" --filter "id=$container")
                  echo "üõë Stopping and removing container: $CONTAINER_NAME_FULL"
                  docker rm -f "$container"
                done
              else
                echo "‚ÑπÔ∏è  No containers found for branch: $BRANCH"
              fi
            fi

            # Remove nginx config
            echo "üóëÔ∏è  Removing nginx configuration..."
            if [ -f "/etc/nginx/sites-enabled/$DOMAIN" ]; then
              sudo rm -f "/etc/nginx/sites-enabled/$DOMAIN"
              echo "‚úÖ Removed nginx sites-enabled: $DOMAIN"
            else
              echo "‚ÑπÔ∏è  No nginx sites-enabled found: $DOMAIN"
            fi

            if [ -f "/etc/nginx/sites-available/$DOMAIN" ]; then
              sudo rm -f "/etc/nginx/sites-available/$DOMAIN"
              echo "‚úÖ Removed nginx sites-available: $DOMAIN"
            else
              echo "‚ÑπÔ∏è  No nginx sites-available found: $DOMAIN"
            fi

            # Test nginx configuration
            if sudo nginx -t 2>/dev/null; then
              sudo systemctl reload nginx
              echo "‚úÖ Nginx configuration reloaded"
            else
              echo "‚ö†Ô∏è  Nginx configuration test failed, but continuing cleanup"
            fi

            # Remove deployment directory
            echo "üóëÔ∏è  Removing deployment directory..."
            if [ -d "$DEPLOYMENT_DIR/backend" ]; then
              rm -rf "$DEPLOYMENT_DIR/backend"
              echo "‚úÖ Removed backend directory: $DEPLOYMENT_DIR/backend"
            else
              echo "‚ÑπÔ∏è  No backend directory found: $DEPLOYMENT_DIR/backend"
            fi

            # Remove parent directory if empty
            if [ -d "$DEPLOYMENT_DIR" ]; then
              if [ -z "$(ls -A "$DEPLOYMENT_DIR" 2>/dev/null)" ]; then
                rm -rf "$DEPLOYMENT_DIR"
                echo "‚úÖ Removed empty deployment directory: $DEPLOYMENT_DIR"
              else
                echo "‚ÑπÔ∏è  Deployment directory not empty, keeping: $DEPLOYMENT_DIR"
                echo "üìÅ Contents: $(ls -la "$DEPLOYMENT_DIR")"
              fi
            else
              echo "‚ÑπÔ∏è  No deployment directory found: $DEPLOYMENT_DIR"
            fi

            echo "‚úÖ Backend cleanup completed for $BRANCH"

      - name: Cleanup GHCR images for PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.number;
            const prTag = `pr-${prNumber}`;

            console.log(`üßπ Cleaning up GHCR images for PR #${prNumber}`);
            console.log(`üîç Looking for images tagged with: ${prTag}`);

            try {
              // Get all package versions for backend
              const { data: versions } = await github.rest.packages.getAllPackageVersionsForPackageOwnedByAuthenticatedUser({
                package_type: 'container',
                package_name: `${context.repo.owner}/${context.repo.repo}/backend`,
                per_page: 100
              });
              
              console.log(`üì¶ Found ${versions.length} total backend package versions`);
              
              let deletedCount = 0;
              
              for (const version of versions) {
                const tags = version.metadata?.container?.tags || [];
                console.log(`üîç Version ${version.id}: tags = [${tags.join(', ')}]`);
                
                // Check if this version has the PR tag
                if (tags.includes(prTag)) {
                  console.log(`üóëÔ∏è  Deleting version ${version.id} (tagged with ${prTag})`);
                  
                  try {
                    await github.rest.packages.deletePackageVersionForAuthenticatedUser({
                      package_type: 'container',
                      package_name: `${context.repo.owner}/${context.repo.repo}/backend`,
                      package_version_id: version.id
                    });
                    
                    console.log(`‚úÖ Successfully deleted version ${version.id}`);
                    deletedCount++;
                  } catch (error) {
                    console.log(`‚ùå Failed to delete version ${version.id}: ${error.message}`);
                  }
                } else {
                  console.log(`‚è© Keeping version ${version.id} (no PR tag)`);
                }
              }
              
              console.log(`üìä GHCR cleanup summary: deleted ${deletedCount} backend images for PR #${prNumber}`);
              
            } catch (error) {
              console.log(`‚ö†Ô∏è  Error during GHCR cleanup: ${error.message}`);
              // Don't fail the workflow if GHCR cleanup fails
            }

      - name: Comment on cleanup
        uses: marocchino/sticky-pull-request-comment@v2.1.0
        with:
          header: "backend-deployment"
          message: |
            ## üßπ Deployment Cleaned Up

            The staging deployment for this PR has been automatically removed.

            - **Container**: Stopped and removed
            - **Nginx config**: Removed
            - **Files**: Cleaned up

            _Deployment resources have been freed up._
